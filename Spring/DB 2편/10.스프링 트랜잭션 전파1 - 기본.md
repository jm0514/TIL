# 스프링 트랜잭션 전파1 - 기본
### 스프링 트랜잭션 전파1 - 커밋, 롤백
* 트랜잭션이 둘 이상 있을 때 어떻게 동작하는지 알아보고, 스프링이 제공하는 트랜잭션 전파(propagation)라는 개념도 알아보자.
### 스프링 트랜잭션 전파2 - 트랜잭션 두 번 사용
```java
@Slf4j
@SpringBootTest
public class BasicTxTest {
    
     @Autowired
     PlatformTransactionManager txManager;
     
     @TestConfiguration
     static class Config {
         @Bean
         public PlatformTransactionManager transactionManager(DataSource dataSource) {
         return new DataSourceTransactionManager(dataSource);
         }
     }
     
     @Test
     void commit() {
         log.info("트랜잭션 시작");
         TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());
         log.info("트랜잭션 커밋 시작");
         txManager.commit(status);
         log.info("트랜잭션 커밋 완료");
     }
     
     @Test
     void rollback() {
         log.info("트랜잭션 시작");
         TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());
         log.info("트랜잭션 롤백 시작");
         txManager.rollback(status);
         log.info("트랜잭션 롤백 완료");
     }

    @Test
    void double_commit() {
        log.info("트랜잭션1 시작");
        TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());
        log.info("트랜잭션1 커밋");
        txManager.commit(tx1);
        
        log.info("트랜잭션2 시작");
        TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());
        log.info("트랜잭션2 커밋");
        txManager.commit(tx2);
    }
     
}
```
#### 트랜잭션 1
* `Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction` 
  * 트랜잭션1을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.
* `Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction`
  * 트랜잭션1을 커밋하고, 커넥션 풀에 `conn0` 커넥션을 반납했다.
#### 트랜잭션 2
* `Acquired Connection [HikariProxyConnection@ 778350106 wrapping conn0] for JDBC transaction`
  * 트랜잭션2을 시작하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.
* `Releasing JDBC Connection [HikariProxyConnection@ 778350106 wrapping conn0] after transaction`
  * 트랜잭션2을 커밋하고, 커넥션 풀에서 `conn0` 커넥션을 획득했다.
#### 주의!
* 로그를 보면 트랜잭션1과 트랜잭션2가 같은 `conn0`을 사용중이다. 이것은 중간에 커넥션 풀 때문에 그런 것이다.
* **둘은 완전히 다른 커넥션으로 인지하는 것이 맞다.**
* 히카리 커넥션 풀에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아닌 `내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환한다`.
* `conn0`은 히카리 프록시 커넥션(객체)이다.
* 내부에는 실제 커넥션이 포함되어 있다. 이 객체의 주소를 확인하면 커넥션 풀에서 획득한 커넥션을 구분할 수 있다.
  * 트랜잭션1: `Acquired Connection [HikariProxyConnection@1000000 wrapping conn0]`
  * 트랜잭션2: `Acquired Connection [HikariProxyConnection@2000000 wrapping conn0]`
* 히카리 커넥션풀이 반환해주는 커넥션(`conn0`)을 다루는 프록시 객체의 주소(`@1000000`, `@2000000`)가 서로 다른 것을 확인할 수 있다.
* 결과적으로 conn0을 통해 커넥션이 재사용된 것을 확인 할 수 있고, 서로 다른 프록시 객체의 주소를 통해 각각 커넥션 풀에서 커넥션을 조회한 것을 확인할 수 있다.  

![image](https://user-images.githubusercontent.com/94179449/227465854-ae8d9d6f-8b6e-4e39-84a3-d765a88775d5.png)
![image](https://user-images.githubusercontent.com/94179449/227466116-75c0c0fe-0eb8-4b91-a10f-89b1ce66c15a.png)
* 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.
* 이 경우 트랜잭션을 각자 관리하기 떄문에 전체 트랜잭션을 묶을 수 없다. 예를들어 트랜잭션1이 커밋하고, 트랜잭션2가 롤백하는 경우 트랜잭션1에 저장한 데이터는 커밋되고, 트랜잭션2에서 저장한 데이터는 롤백된다.

### 스프링 트랜잭션 전파3 - 전파 기본
* 트랜잭션을 각각 사용하는 것이 아닌, 이미 진행중인 트랜잭션에 추가로 트랜잭션을 수행하면 어떻게 될까?
* 이런 경우 어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)라 한다.
* 스프링은 다양한 트랜잭션 전파 옵션을 제공한다.
#### 외부 트랜잭션이 수행중인데, 내부 트랜잭션이 추가로 수행됨
* 외부 트랜잭션은 처음 시작된 트랜잭션이라고 이해하면 된다.
* 내부 트랜잭션은 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것 처럼 보여서 내부 트랜잭션이라 한다.
* 스프링은 이러한 경우 외부 트랜잭션과 내부 트랜잭션을 **하나의 트랜잭션**으로 만들어준다. 내부 트랜잭션이 외부 트랜잭션에 참여하는 것이다.  

![image](https://user-images.githubusercontent.com/94179449/227468740-88d53e55-0ef2-4564-8ab2-fa097ad5885d.png)
#### 물리 트랜잭션, 논리 트랜잭션
![image](https://user-images.githubusercontent.com/94179449/227468903-6a9f9d05-5620-49d8-abc1-a3e5e45e2b91.png)
* 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶인다.
* 물리 트랜잭션은 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다. 실제 커넥션을 통해 트랜잭션을 시작, 커밋, 롤백하는 단위이다.
* 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위이다.
* 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타난다. 하나인 경우는 구분하지 않는다.
* 트랜잭션이 사용중일 때 또 다른 트랜잭션이 내부에서 사용되면 여러 복잡한 상황이 생길 수 있기 떄문에 논리 트랜잭션 개념을 도입한다.
#### 원칙
* **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.**
* **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.**

### 스프링 트랜잭션 전파4 - 전파 예제
