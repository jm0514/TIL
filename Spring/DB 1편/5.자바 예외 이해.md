# 자바 예외 이해
### 예외 계층 그림
![image](https://user-images.githubusercontent.com/94179449/224367906-235dfbb1-8684-481c-a751-4bf2589b8cf5.png)
### 예외 기본 규칙
* 1. 예외는 잡아서 처리하거나 던져야 한다.
* 2. 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.
   * 예를 들어서 Exception 을 catch 로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
   * 예를 들어서 Exception 을 throws 로 던지면 그 하위 예외들도 모두 던질 수 있다.
* 예외를 처리하지 못하고 계속 던지게 되면 자바 `main()` 쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다.
### 언체크 예외 VS 체크 예외
* 기본적으로 언체크(런타임)예외를 사용하자.
* 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
  * 이 경우 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 체크 예외를 사용해야 한다.
### 체크 예외 문제점
![image](https://user-images.githubusercontent.com/94179449/224370177-93c83633-2175-4144-a707-77a45221c89a.png)
* 결국 계속 던지게 되면서 의존하고 있던 클래스마다 예외를 던져야 하는 상황이 생겼다.
* **복구 불가능한 예외**
  * 대부분의 서비스나 컨트롤러는 예외 복구가 불가능하다. 
  * 서블릿 필터, 스프링 인터셉터, 스프링의 `ControllerAdvice`를 사용하면 이런 부분을 공통으로 처리할 수 있다.
* **의존 관계에 대한 문제**
  * 서비스, 컨트롤러에서 처리할 수 없는 예외를 의존해야 한다.
  * OCP, DI를 통해 클라이언트 코드의 변경 없이 대상 구현체를 변경할 수 없게 된다.
* **데이터베이스나 네트워크 통신처럼 시스템 레벨에서 올라온 예외들은 서비스나 컨트롤러에서 처리가 불가능하다.**
* 체크 예외의 최상위 타입인 `Exception`을 던지면 모든 예외를 다 던지기 때문에 체크 예외를 의도적으로 사용하는 것이 아니다.
### 언체크 예외 활용
![image](https://user-images.githubusercontent.com/94179449/224375668-dd93ffd5-2306-4188-93a4-ec472f8472af.png)
* **런타임 예외 - 대부분 복구 불가능한 예외**
  * 시스템에서 발생한 예외는 대부분 복구 불가능 예외이다. 
  * 런타임 예외를 사용하면 서비스나 컨트롤러가 이런 복구 불가능한 예외를 신경쓰지 않아도 된다.
* **런타임 예외 - 의존 관계에 대한 문제**
  * 런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시해서 예외를 의존하지 않는다.
* 체크 예외의 문제점 때문에 최근 라이브러리들은 대부분 런타임 예외를 기본으로 제공한다.
* 런타임 예외는 **문서화**를 잘해야 한다.
### 예외 포함과 스택 트레이스
```java
@Test
void printEx() {
     Controller controller = new Controller();
     try {
        controller.request();
     } catch (Exception e) {
        log.info("ex", e);
     }
}
```
* 로그를 출력할 때 마지막 파라미터에 예외를 넣어주면 로그에 스택 트레이스를 출력할 수 있다.
  * 예) `log.info("message={}", "message", ex)` 여기에서 마지막에 ex 를 전달하는 것을 확인할 수 있다. 이렇게 하면 스택 트레이스에 로그를 출력할 수 있다.
  * 예) `log.info("ex", ex)` 지금 예에서는 파라미터가 없기 때문에, 예외만 파라미터에 전달하면 스택 트레이스를 로그에 출력할 수 있다.
